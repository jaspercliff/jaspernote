# 事务隔离级别

在MySQL中，事务隔离级别定义了不同事务之间的可见性和互相影响的程度。每个级别都在数据正确性与性能之间做出不同的平衡。以下是MySQL支持的四种事务隔离级别的详细比较：

| 隔离级别                        | 脏读 (Dirty Read) | 不可重复读 (Non-Repeatable Read) | 幻读 (Phantom Read) | 性能影响 | 适用场景                      |
|-----------------------------|-----------------|-----------------------------|-------------------|------|---------------------------|
| **读未提交 (READ UNCOMMITTED)** | 允许              | 允许                          | 允许                | 最高   | 需要极高性能和数据一致性要求不高的场景       |
| **读提交 (READ COMMITTED)**    | 阻止              | 允许                          | 允许                | 较高   | 需要避免脏读但可以容忍一定级别的不一致的场景    |
| **可重复读 (REPEATABLE READ)**  | 阻止              | 阻止                          | 允许                | 中等   | MySQL的默认隔离级别，平衡了一致性和性能    |
| **串行化 (SERIALIZABLE)**      | 阻止              | 阻止                          | 阻止                | 最低   | 数据完整性要求非常高的场景，如金融服务中的某些操作 |

### 详细说明

- **读未提交 (READ UNCOMMITTED)**：这是最低的隔离级别，事务可以看到其他事务未提交的数据更改。这种级别可能会导致脏读，即一个事务读取到另一个事务未提交的数据，如果那个事务回滚，读取的数据就是无效的。

- **读提交 (READ COMMITTED)**：保证一个事务从开始到结束只能看见已经提交的事务所做的更改。这样可以防止脏读，但仍然可能发生不可重复读和幻读。

- **可重复读 (REPEATABLE READ)**
  ：MySQL的默认隔离级别。在这个级别下，事务保证在整个事务期间可以多次读取同样的数据行，结果都是一致的，即防止了不可重复读。但是，它可能无法防止幻读，即事务读取某个范围的记录时，另一个事务插入了新的记录。

- **串行化 (SERIALIZABLE)**：这是最高的隔离级别，通过强制事务串行执行，避免幻读，实现严格的事务隔离。这个级别可以通过锁定事务涉及的所有数据来避免脏读、不可重复读和幻读，但性能损耗较大，因为减少了并发性。

### 设置和查询隔离级别

设置隔离级别的命令：

``` sql
SET TRANSACTION ISOLATION LEVEL <desired level >;
```

例如，设置为 REPEATABLE READ：

``` sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

查询当前会话的隔离级别：

``` sql
SELECT @@tx_isolation;
```

在MySQL 8.0以上版本中，该变量已经更名为 `@@transaction_isolation`。

调整和选择合适的隔离级别可以帮助平衡性能和数据正确性的需求，适应不同的应用场景需求。