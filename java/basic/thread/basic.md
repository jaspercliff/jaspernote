# 线程
## 并发三要素(出现问题的根源)
- 原子性
  - 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
- 有序性
  - 程序执行的顺序按照代码的先后顺序执行
- 可见性
  - 一个线程对共享变量的修改，另外一个线程能够立刻看到

## 为什么需要多线程
CPU、内存、I/O 设备的速度是有极大差异的
- CPU 增加了缓存，以均衡与内存的速度差异 //可见性
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异 //原子性
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用 //有序性
### 可见性
``` java
//线程1执行的代码
int i = 0;
i = 10;
//线程2执行的代码
j = i;
```
假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，
会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，
却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，
注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10
### 原子性
``` java
nt i = 1;
// 线程1执行
i += 1;
// 线程2执行
i += 1;
```
i += 1需要三条 CPU 指令
将变量 i 从内存读取到 CPU寄存器；
在CPU寄存器中执行 i + 1 操作；
将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。
由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，
假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3
### 顺序性
Java源代码到最终实际执行的指令序列，会经历编译期重排序、类加载期重排序以及运行时重排序三个阶段的重新排序。
这些重排序主要是由Java编译器、JVM（Java虚拟机）和CPU来共同完成的，目的是为了优化程序性能，但需要保证最终执行结果与Java内存模型（JMM）规定的结果一致。

#### 1. 编译期重排序

在编译期间，Java编译器（javac）会将你的Java源代码编译成字节码（.class文件）。在这个过程中，编译器可能会对代码进行重排序，以优化程序运行的性能。这种重排序包括但不限于指令重排、循环变换等，目的是提高代码的执行效率。重排序在遵循Java内存模型的前提下进行，确保在单线程环境下程序的执行行为不会改变。

#### 2. 类加载期重排序

在类加载时，JVM的类加载器会将字节码转换成JVM内部的表示，并进行链接、初始化等一系列操作。在这个阶段，可能会有一些重排序发生，特别是在解析阶段，JVM为了优化程序性能，可能会进行一定的优化处理。

#### 3. 运行时重排序

运行时重排序主要发生在JIT编译过程中和CPU层面：

- **JIT编译期重排序**：JVM的即时编译器（Just-In-Time, JIT）在运行时将热点代码（经常执行的代码）编译成本地机器代码，以提高执行效率。JIT编译器在进行编译时，也可能会对指令进行重排序，
- 包括但不限于指令合并、循环展开、方法内联等优化措施。

- **CPU重排序**：现代处理器为了利用执行单元的并行能力，提高指令执行的吞吐率，会在执行机器指令时进行指令级的并行和重排序。
- 这种重排序是透明的，程序员通常不需要关心，但它是实现高性能计算的关键技术之一。

为了保证多线程程序的正确性，Java内存模型定义了一套规则来协调这些重排序，确保在多线程环境中，程序行为的一致性和正确性。
JMM通过happens-before规则来保证特定的编程模式下内存操作的可见性和有序性，避免了因重排序导致的数据竞争和内存一致性问题。

## 并发三要素(出现问题的根源)
原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x = x + 1;     //语句4： 同语句3
上面4个语句只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。



## 实现线程的三种方式
