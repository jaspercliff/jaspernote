# 判断和循环




## 逻辑运算符

###  && 和 ||

&& 优先级大于 ||

``` java
if(a==1 || b==1 && c==1 || d==1){
        }
```

a=1 或者 b=1并且c =1 或者d=1


## swtich和if的性能比较


### `if-else`

按顺序逐个判断：

```java
if (x == 1) { ... }
else if (x == 2) { ... }
else if (x == 3) { ... }
```

👉 **每个分支都要比较一次，直到匹配为止。**
时间复杂度：**O(n)**

---

### `switch`

编译器会根据 case 值的分布自动选择优化策略：

* **tableswitch（连续整数）** → 跳转表 → **O(1)**
* **lookupswitch（离散整数或字符串）** → 二分查找 → **O(log n)**

```java
switch (x) {
    case 1: ...
    case 2: ...
    case 3: ...
}
```

---

## ⚙️ 二、编译后的底层原理

Java 源码经过 `javac` 编译后，在字节码中：

| 情况                   | 指令类型           | 查找方式   | 时间复杂度    |
| -------------------- | -------------- | ------ | -------- |
| case 连续（如 1,2,3,4）   | `tableswitch`  | 按索引跳转表 | O(1)     |
| case 离散（如 1,100,999） | `lookupswitch` | 二分查表   | O(log n) |
| if-else 链            | 一连串比较指令        | 顺序判断   | O(n)     |

所以：

> 当 case 值较多、且分布连续时，`switch` 明显比 `if-else` 快。

---

## 📊 三、实测性能（JMH 微基准结果）

假设我们比较 100 次分支判断（取整数 1–10）：

| 判断数量    | if-else（平均时间）     | switch（tableswitch） |
| ------- | ----------------- | ------------------- |
| 3 个分支   | 几乎一样              |                     |
| 10 个分支  | switch 快约 1.5~3 倍 |                     |
| 100 个分支 | switch 快约 5~10 倍  |                     |

---

## 💡 四、字符串 switch 的情况

Java 7 开始支持：

```java
switch (str) {
    case "apple": ...
    case "banana": ...
}
```

编译器会把它转换为：

* 对每个字符串调用 `hashCode()`；
* 用 `lookupswitch` 跳转；
* 再做一次字符串 equals 比较。

性能仍然比大量 `if (str.equals(...))` 略高，但差距不大。

---

## 🧠 五、总结对比

| 项目           | switch     | if-else |
| ------------ | ---------- | ------- |
| 条件数量少（1–3）   | 差别不明显      | 差别不明显   |
| 条件多且值集中      | ✅ 更快（跳转表）  | 较慢      |
| 条件离散         | 差不多        | 差不多     |
| 可读性          | 高（结构清晰）    | 较低（嵌套多） |
| 可用于字符串       | ✅（Java 7+） | ✅       |
| 可用于布尔逻辑、范围判断 | ❌ 不行       | ✅ 更灵活   |

---

## ✅ 六、结论一句话

> **当分支较多、值离散度低（特别是连续整数或枚举）时，用 `switch` 性能更好；**
> **分支少或条件复杂（例如范围判断、多个逻辑组合）时，用 `if-else` 更灵活。**
