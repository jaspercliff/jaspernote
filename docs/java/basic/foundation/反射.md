# reflection

ä¸€èˆ¬æˆ‘ä»¬åœ¨ä½¿ç”¨æŸä¸ªç±»ä¹‹å‰å°±ç¡®å®šäº†æ˜¯ä»€ä¹ˆç±»ï¼Œç›´æ¥å¯ä»¥newæ¥è¿›è¡Œå®ä¾‹åŒ–æ¥è¿›è¡Œæ“ä½œ

åå°„å°±æ˜¯ä¸€å¼€å§‹ä¸çŸ¥é“è¦åˆå§‹åŒ–çš„ç±»ï¼Œä¸èƒ½ä½¿ç”¨newæ¥å®ä¾‹åŒ–

å®ƒå…è®¸åœ¨è¿è¡Œæ—¶æ£€æŸ¥å’Œæ“ä½œç±»ã€æ¥å£ã€å­—æ®µå’Œæ–¹æ³•

æ¡†æ¶çš„çµé­‚

é€šè¿‡åå°„ä½ å¯ä»¥è·å–ä»»æ„ä¸€ä¸ªç±»çš„æ‰€æœ‰å±æ€§å’Œæ–¹æ³•ï¼Œè¿˜å¯ä»¥è°ƒç”¨è¿™äº›æ–¹æ³•

åœ¨spring springboot mybatisä¸­éƒ½ä½¿ç”¨äº†

* jdkä¸­çš„åŠ¨æ€ä»£ç† [ä»£ç†æ¨¡å¼](/docs/patterns/structural/proxy.md)
* æ³¨è§£   [annotation](æ³¨è§£.md)
* jdbc [jdbc](../../jdbc/index.md)

## ä¼˜ç‚¹

* ä»£ç æ›´åŠ çµæ´»ï¼Œä¸ºæ¡†æ¶æä¾›äº†ä¾¿åˆ©é€šè¿‡é…ç½®æ–‡ä»¶æ¥åŠ è½½ä¸åŒçš„å¯¹è±¡ï¼Œè°ƒç”¨ä¸åŒçš„æ–¹æ³•
* åœ¨è¿è¡Œæ—¶æœ‰äº†åˆ†ææ“ä½œç±»çš„èƒ½åŠ›

## ç¼ºç‚¹

* ç ´åäº†å°è£…ï¼Œå…è®¸è®¿é—®private method and param
* å¢åŠ äº†å®‰å…¨é—®é¢˜ï¼Œæ— è§†æ³›å‹å‚æ•°çš„æ£€æŸ¥
  * [æ³›å‹æ“¦é™¤](https://www.notion.so/a6c5e2af5b9e41c7b5d7d3be7ab4f1d1?pvs=21)
* æ€§èƒ½ç›¸å¯¹å·®ä¸€ç‚¹

æ¯ä¸€ä¸ªç±»çš„å®ä¾‹éƒ½ä¼šå¯¹åº”ä¸€ä¸ªClasså¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ç”±jvmç”Ÿæˆæ¥è·å–æ•´ä¸ªç±»çš„ç»“æ„ä¿¡æ¯

## Class

Classï¼šä»£è¡¨ä¸€ä¸ªç±»æˆ–æ¥å£ï¼ŒåŒ…å«äº†ç±»çš„ç»“æ„ä¿¡æ¯ï¼ˆå¦‚åç§°ã€æ„é€ å‡½æ•°ã€æ–¹æ³•ã€å­—æ®µç­‰ï¼‰ã€‚é€šè¿‡ Class å¯¹è±¡ï¼Œå¯ä»¥è·å–ç±»çš„å…ƒæ•°æ®å¹¶æ“ä½œç±»çš„å®ä¾‹

```java
package com.jasper.reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Demo1 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> clazz = Class.forName("com.jasper.reflection.Person");
        Constructor<?> constructor = clazz.getConstructor();
        Object o = constructor.newInstance();
        Method setName = clazz.getMethod("setName", String.class);
        setName.invoke(o,"jasper");
        Method getName = clazz.getMethod("getName");
        System.out.println(getName.invoke(o));
    }
}
```

```java
package com.jasper.reflection;

public class Person {
    private String name;
    private String age;

    public Person() {
    }

     private Person(String name, String age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public void print(){
        System.out.println("print method");
    }

    private void print(String name){
        System.out.println(name);
    }
}
```

## è·å–Classå¯¹è±¡

* Class.forName()  @param className the fully qualified name of the desired class.

  ```java
  @CallerSensitive
      public static Class<?> forName(String className)
                  throws ClassNotFoundException {
          Class<?> caller = Reflection.getCallerClass();
          return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
      }
  ```

* ç±»å.class  é€‚åˆåœ¨ç¼–è¯‘å‰å°±çŸ¥é“æ“ä½œçš„Class
* å¯¹è±¡.getClass()

```java
Class<?> clazz = Class.forName("com.jasper.reflection.Person");
        Class<Person> clazz1 = Person.class;
        Person person = new Person();
        Class<? extends Person> clazz2 = person.getClass();
        System.out.println(clazz == clazz1);
        System.out.println(clazz1 == clazz2);

```

* ç±»åŠ è½½å™¨(ç³»ç»Ÿç±»åŠ è½½å™¨ åº”ç”¨ç±»åŠ è½½å™¨ï¼‰

```java
Class<?> clazz1 = ClassLoader.getSystemClassLoader().loadClass("com.jasper.reflection.Person");
```

## åˆ›å»ºåå°„ç±»çš„å¯¹è±¡

* Classå¯¹è±¡çš„newInstanceæ–¹æ³•
* Constructorå¯¹è±¡çš„newInstance method

```java
Object o = clazz.newInstance();
        Object o1 = clazz.getConstructor().newInstance();
        System.out.println(o);
        System.out.println(o1);
```

## è·å–æ„é€ æ–¹æ³•

``` java
//        Constructor<?> constructor = clazz.getConstructor(String.class, String.class);
//        System.out.println(constructor);
//        no param æ— å‚constructor
        System.out.println(clazz.getConstructor());

//        include private and protected method
        Constructor<?> declaredConstructor = clazz.getDeclaredConstructor();
        System.out.println("declaredConstructor = " + declaredConstructor);
        Constructor<?> declaredConstructor1 = clazz.getDeclaredConstructor(String.class, String.class);
        System.out.println("declaredConstructor1 = " + declaredConstructor1);
//        get all public constructor
        Constructor<?>[] constructors = clazz.getConstructors();
        System.out.println("constructors = " + constructors);
//        get all constructor include private
        Constructor<?>[] declaredConstructors = clazz.getDeclaredConstructors();
        System.out.println("declaredConstructors = " + declaredConstructors);
```

## è·å–å­—æ®µ

```java
Method setNameMethod = clazz.getMethod("setName", String.class);
Method getNameMethod = clazz.getMethod("getName");
```

## è·å–æ–¹æ³•

```java
Method print = clazz.getMethod("print");
        System.out.println("print = " + print);
        Method print1 = clazz.getDeclaredMethod("print", String.class);
        System.out.println("print1 = " + print1);
        print1.invoke(o,"jasper");
```

output

``` java
print = public void com.jasper.reflection.Person.print()
print1 = private void com.jasper.reflection.Person.print(java.lang.String)
Exception in thread "main" java.lang.IllegalAccessException: Class com.jasper.reflection.Demo2 can not access a member of class com.jasper.reflection.Person with modifiers "private"
 at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)
 at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)
 at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)
 at java.lang.reflect.Method.invoke(Method.java:491)
 at com.jasper.reflection.Demo2.main(Demo2.java:42)
```

å¦‚æœæƒ³åå°„è®¿é—®ç§æœ‰å­—æ®µå’Œï¼ˆæ„é€ ï¼‰æ–¹æ³•æ—¶ï¼Œéœ€è¦ä½¿ç”¨Constructor/field/method.setAccessible(true)

```java
Method print1 = clazz.getDeclaredMethod("print", String.class);
        System.out.println("print1 = " + print1);
        print1.setAccessible(true);
        print1.invoke(o,"jasper");
```

output

```java
print1 = private void com.jasper.reflection.Person.print(java.lang.String)
jasper
```

## invoke method

![image.png](assets/01reflection.png)

**`root`** å±æ€§é€šå¸¸ç”¨äºå®ç°æ–¹æ³•è°ƒç”¨çš„ä¼˜åŒ–ã€‚å®ƒç”¨äºç»´æŠ¤ **`Method`** å¯¹è±¡ä¹‹é—´çš„å…³è”å…³ç³»ï¼Œç‰¹åˆ«æ˜¯åœ¨æ¶‰åŠæ–¹æ³•è®¿é—®å™¨ï¼ˆ**`MethodAccessor`**ï¼‰çš„æƒ…å†µä¸‹

Method

```java
@CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
//æ˜¯å¦è¿›è¡Œæƒé™æ£€æŸ¥
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class<?> caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
//è·å–æ–¹æ³•è®¿é—®å™¨
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
//è·å–æ–¹æ³•è®¿é—®å™¨
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    }
```

```java

private MethodAccessor acquireMethodAccessor() {
        // First check to see if one has been created yet, and take it
        // if so
        MethodAccessor tmp = null;
        if (root != null) tmp = root.getMethodAccessor();
        if (tmp != null) {
            methodAccessor = tmp;
        } else {
            // Otherwise fabricate(åˆ¶é€ ï¼‰ one and propagate it up to the root
            tmp = reflectionFactory.newMethodAccessor(this);
            setMethodAccessor(tmp);
        }

        return tmp;
    }
```

ReflectionFactory

```java
public MethodAccessor newMethodAccessor(Method var1) {
        checkInitted();
        if (noInflation && !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) {
            return (new MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());
        } else {
            NativeMethodAccessorImpl var2 = new NativeMethodAccessorImpl(var1);
            DelegatingMethodAccessorImpl var3 = new DelegatingMethodAccessorImpl(var2);
            var2.setParent(var3);
            return var3;
        }
    }
```

ä»£ç†æ¨¡å¼ï¼Œå°†NativeMethodAccessorImplç»™DelegatingMethodAccessorImplä»£ç†

ä»£ç†æ¨¡å¼å¯ä»¥åœ¨æœ¬åœ°å®ç°å’ŒåŠ¨æ€å®ç°ä¹‹é—´åˆ‡æ¢

```java
package sun.reflect;

import java.lang.reflect.InvocationTargetException;

class DelegatingMethodAccessorImpl extends MethodAccessorImpl {
    private MethodAccessorImpl delegate;

    DelegatingMethodAccessorImpl(MethodAccessorImpl var1) {
        this.setDelegate(var1);
    }

    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {
        return this.delegate.invoke(var1, var2);
    }

    void setDelegate(MethodAccessorImpl var1) {
        this.delegate = var1;
    }
}
```

å°†NativeMethodAccessorImplç»™äº†DelegatingMethodAccessorImplçš„delegateå±æ€§

newMethodAccessoræœ€åè¿”å›äº†DelegatingMethodAccessorImpl

ma.invoke è¿›å…¥äº†DelegatingMethodAccessorImplçš„invokeæ–¹æ³•

delegateæ˜¯MethodAccessorImpl

![image.png](assets/02reflection.png)

è¿™é‡Œçš„ delegate å…¶å®æ˜¯ä¸€ä¸ª NativeMethodAccessorImpl å¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œä¼šè¿›å…¥ NativeMethodAccessorImpl çš„ invoke æ–¹æ³•ã€‚

```java
class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private final Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;

    NativeMethodAccessorImpl(Method var1) {
        this.method = var1;
    }

    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {
        if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {
            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());
            this.parent.setDelegate(var3);
        }

        return invoke0(this.method, var1, var2);
    }

    void setParent(DelegatingMethodAccessorImpl var1) {
        this.parent = var1;
    }

    private static native Object invoke0(Method var0, Object var1, Object[] var2);
}
```

åœ¨ NativeMethodAccessorImpl çš„ invoke æ–¹æ³•é‡Œï¼Œå…¶ä¼šåˆ¤æ–­è°ƒç”¨æ¬¡æ•°æ˜¯å¦è¶…è¿‡é˜€å€¼ï¼ˆnumInvocationsï¼‰ã€‚å¦‚æœè¶…è¿‡è¯¥é˜€å€¼15ï¼Œé‚£ä¹ˆå°±ä¼šç”Ÿæˆå¦ä¸€ä¸ªMethodAccessor å¯¹è±¡ï¼Œ
å¹¶å°†åŸæ¥ DelegatingMethodAccessorImpl å¯¹è±¡ä¸­çš„ delegate å±æ€§æŒ‡å‘æœ€æ–°çš„ MethodAccessor å¯¹è±¡

Native ç‰ˆæœ¬ä¸€å¼€å§‹å¯åŠ¨å¿«ï¼Œä½†æ˜¯éšç€è¿è¡Œæ—¶é—´è¾¹é•¿ï¼Œé€Ÿåº¦å˜æ…¢ã€‚Java ç‰ˆæœ¬ä¸€å¼€å§‹åŠ è½½æ…¢ï¼Œä½†æ˜¯éšç€è¿è¡Œæ—¶é—´è¾¹é•¿ï¼Œé€Ÿåº¦å˜å¿«ã€‚æ­£æ˜¯å› ä¸ºä¸¤ç§å­˜åœ¨è¿™äº›é—®é¢˜ï¼Œ
æ‰€ä»¥ç¬¬ä¸€æ¬¡åŠ è½½çš„æ—¶å€™æˆ‘ä»¬ä¼šå‘ç°ä½¿ç”¨çš„æ˜¯ NativeMethodAccessorImpl çš„å®ç°ï¼Œè€Œå½“åå°„è°ƒç”¨æ¬¡æ•°è¶…è¿‡ 15 æ¬¡ä¹‹åï¼Œåˆ™ä½¿ç”¨ MethodAccessorGenerator ç”Ÿæˆçš„ MethodAccessorImpl å¯¹è±¡å»å®ç°åå°„

## æ–¹æ³•

åœ¨Javaåå°„APIä¸­ï¼Œ`Class`ç±»æä¾›äº†ä¸¤ç§æ–¹æ³•æ¥è·å–ç±»ä¸­çš„æ–¹æ³•ä¿¡æ¯ï¼š`getDeclaredMethods()`å’Œ`getMethods()`ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•çš„ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬è¿”å›çš„æ–¹æ³•é›†åˆä¸åŒã€‚

### getDeclaredMethods()

* **è¿”å›å€¼**ï¼š`getDeclaredMethods()`æ–¹æ³•è¿”å›`Method`å¯¹è±¡çš„æ•°ç»„ï¼Œè¿™äº›å¯¹è±¡åæ˜ äº†ç”±è¯¥`Class`å¯¹è±¡è¡¨ç¤ºçš„ç±»æˆ–æ¥å£**å£°æ˜çš„æ‰€æœ‰æ–¹æ³•**ï¼ŒåŒ…æ‹¬å…¬å…±ã€ä¿æŠ¤ã€é»˜è®¤ï¼ˆåŒ…ï¼‰è®¿é—®å’Œç§æœ‰æ–¹æ³•ï¼Œä½†**ä¸åŒ…æ‹¬ç»§æ‰¿çš„æ–¹æ³•**ã€‚
* **ä½¿ç”¨åœºæ™¯**ï¼šå½“ä½ æƒ³è¦è·å–ä¸€ä¸ªç±»ä¸­å£°æ˜çš„æ‰€æœ‰æ–¹æ³•ï¼ŒåŒ…æ‹¬ç§æœ‰æ–¹æ³•ï¼Œè€Œä¸å…³å¿ƒå…¶çˆ¶ç±»æˆ–æ¥å£çš„æ–¹æ³•æ—¶ï¼Œä½¿ç”¨`getDeclaredMethods()`ã€‚

### getMethods()

* **è¿”å›å€¼**ï¼š`getMethods()`æ–¹æ³•è¿”å›ä¸€ä¸ª`Method`å¯¹è±¡æ•°ç»„ï¼Œè¿™äº›å¯¹è±¡åæ˜ äº†ç”±è¯¥`Class`å¯¹è±¡è¡¨ç¤ºçš„ç±»æˆ–æ¥å£çš„**æ‰€æœ‰å…¬å…±æ–¹æ³•**ï¼Œè¿™åŒ…æ‹¬å®ƒè‡ªèº«å£°æ˜çš„å’Œä»å®ƒçš„æ‰€æœ‰çˆ¶ç±»ç»§æ‰¿çš„å…¬å…±æ–¹æ³•ã€‚
* **ä½¿ç”¨åœºæ™¯**ï¼šå½“ä½ åªå¯¹è·å–ä¸€ä¸ªç±»çš„æ‰€æœ‰å…¬å…±æ¥å£ï¼ŒåŒ…æ‹¬å…¶çˆ¶ç±»çš„å…¬å…±æ–¹æ³•æ„Ÿå…´è¶£æ—¶ï¼Œä½¿ç”¨`getMethods()`ã€‚

### ç¤ºä¾‹

å‡è®¾æœ‰ä»¥ä¸‹ç±»ç»“æ„ï¼š

```java
public class SuperClass {
    public void publicMethod() {}
    protected void protectedMethod() {}
    private void privateMethod() {}
}

public class SubClass extends SuperClass {
    public void publicSubMethod() {}
    private void privateSubMethod() {}
}
```

* ä½¿ç”¨`SubClass.class.getDeclaredMethods()`å°†åªè¿”å›`SubClass`ä¸­å£°æ˜çš„æ–¹æ³•ï¼Œå³`publicSubMethod()`å’Œ`privateSubMethod()`ï¼Œä¸è®ºå®ƒä»¬çš„è®¿é—®æƒé™å¦‚ä½•ã€‚
* ä½¿ç”¨`SubClass.class.getMethods()`å°†è¿”å›`SubClass`ä»¥åŠå…¶è¶…ç±»`SuperClass`ä¸­çš„æ‰€æœ‰å…¬å…±æ–¹æ³•ï¼Œå³`publicMethod()`å’Œ`publicSubMethod()`ã€‚

### æ€»ç»“

* ä½¿ç”¨`getDeclaredMethods()`è·å–ä¸€ä¸ªç±»ä¸­å®šä¹‰çš„æ‰€æœ‰æ–¹æ³•ï¼Œä¸åŒ…æ‹¬çˆ¶ç±»æ–¹æ³•ã€‚
* ä½¿ç”¨`getMethods()`è·å–ç±»çš„æ‰€æœ‰å…¬å…±æ–¹æ³•ï¼ŒåŒ…æ‹¬å…¶ç»§æ‰¿çš„æ–¹æ³•ã€‚

é€‰æ‹©å“ªä¸€ä¸ªæ–¹æ³•å–å†³äºä½ çš„å…·ä½“éœ€æ±‚ï¼Œæ˜¯å¦éœ€è¦è®¿é—®ç§æœ‰æ–¹æ³•æˆ–è€…æ˜¯åªå…³å¿ƒå…¬å…±æ¥å£ã€‚

## class.getResourceAsStream

åœ¨ Java ä¸­ï¼Œ`getResourceAsStream(String name)` æ–¹æ³•ç”¨äºä» **classpathï¼ˆç±»è·¯å¾„ï¼‰** ä¸­åŠ è½½èµ„æºæ–‡ä»¶ï¼Œå¹¶è¿”å›ä¸€ä¸ª `InputStream`ï¼Œæ–¹ä¾¿è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆå¦‚é…ç½®æ–‡ä»¶ã€å›¾ç‰‡ã€æ¨¡æ¿ç­‰ï¼‰ã€‚

---

### âœ… å¸¸è§ç”¨æ³•

```java
InputStream is = MyClass.class.getResourceAsStream("/config.properties");
```

---

### ğŸ“˜ å‚æ•°è¯´æ˜

* **è·¯å¾„å†™æ³•ï¼ˆé‡ç‚¹ï¼‰**ï¼š
  * `/xxx`ï¼š**ä» classpath æ ¹ç›®å½•å¼€å§‹**æŸ¥æ‰¾ï¼ˆç»å¯¹è·¯å¾„ï¼‰
  * `xxx`ï¼š**ç›¸å¯¹äºå½“å‰ç±»æ‰€åœ¨åŒ…è·¯å¾„**æŸ¥æ‰¾ï¼ˆç›¸å¯¹è·¯å¾„ï¼‰

---

### ç¤ºä¾‹è®²è§£

å‡è®¾èµ„æºè·¯å¾„ä¸ºï¼š

```text
src/main/resources/config/app.properties
```

#### 1. ç»å¯¹è·¯å¾„ï¼ˆæ¨èï¼‰

```java
InputStream is = MyClass.class.getResourceAsStream("/config/app.properties");
```

ä» classpath æ ¹ç›®å½•æŸ¥æ‰¾ï¼Œ**æœ€å¸¸ç”¨**ã€‚

#### 2. ç›¸å¯¹è·¯å¾„ï¼ˆä¸æ¨èï¼‰

å‡å¦‚ `MyClass` åœ¨ `com.example.util` åŒ…ä¸­ï¼š

```java
InputStream is = MyClass.class.getResourceAsStream("app.properties");
```

è¿™ä¼šå»æ‰¾ï¼š`com/example/util/app.properties`

---

### â—æ³¨æ„äº‹é¡¹

* **`getClass().getResourceAsStream(...)` å’Œ `ClassLoader.getResourceAsStream(...)` ä¸ä¸€æ ·**ï¼š
  * `getClass().getResourceAsStream("/xxx")`ï¼šä» classpath æ ¹è·¯å¾„æŸ¥æ‰¾
  * `ClassLoader.getResourceAsStream("xxx")`ï¼šé»˜è®¤å°±æ˜¯ä»æ ¹è·¯å¾„æŸ¥æ‰¾ï¼Œä¸éœ€è¦ `/`

### ç¤ºä¾‹1

rocketmq dashboard æºç 

```java
    public AbstractFileStore(RMQConfigure configure, String fileName) {
        filePath = configure.getRocketMqDashboardDataPath() + File.separator + fileName;
        // æ–‡ä»¶ä¸å­˜åœ¨å°±å»è¯»å–ç±»è·¯å¾„ä¸‹çš„é…ç½®æ–‡ä»¶ 
        if (!new File(filePath).exists()) {
            // Use the default path
            InputStream inputStream = getClass().getResourceAsStream("/" + fileName);
            if (inputStream == null) {
                log.error(String.format("Can not found the file %s in Spring Boot jar", fileName));
                System.exit(1);
            } else {
                try {
                    load(inputStream);
                } catch (Exception e) {
                    log.error("fail to load file {}", filePath, e);
                } finally {
                    try {
                        inputStream.close();
                    } catch (IOException e) {
                        log.error("inputStream close exception", e);
                    }
                }
            }
        } else {
            log.info(String.format("configure file is %s", filePath));
            load();
            watch();
        }
    }
```

