# JMM java memory model
## 1. 主要目标

- **可见性**：保证一个线程对共享变量的修改对其他线程是可见的。
- **原子性**：保证复合操作的整体性，即操作是完整执行或完整不执行。
- **有序性**：保证程序执行的顺序按照代码的先后顺序进行。
## 2. `happens-before`原则
JMM通过`happens-before`原则来具体化操作之间的内存可见性和有序性规则。
`happens-before`关系是JMM中最核心的概念之一，它定义了两个操作之间的偏序关系。
如果一个操作happens-before另一个操作，那么第一个操作的结果对第二个操作是可见的，
且第一个操作在逻辑上先于第二个操作发生。

1. **程序顺序规则**：在一个线程中，按照程序代码顺序，前面的操作happens-before于后续的操作。
2. **监视器锁规则**：对一个锁的**解锁**操作happens-before于随后对这个锁的**加锁**操作。
3. **`volatile`变量规则**：对一个`volatile`域的**写**操作happens-before于任意后续对这个`volatile`域的**读**操作。
4. **线程启动规则**：Thread对象的start()方法happens-before于此线程的每一个动作。
5. **线程终止规则**：线程中的所有操作都happens-before于其他线程检测到这个线程已经终止的动作，通过Thread.join()方法或者`isAlive()`返回false。
6. **线程中断规则**：对线程interrupt()的调用happens-before于被中断线程的代码检测到中断事件的发生。
7. **对象终结规则**：一个对象的初始化完成（构造函数执行结束）happens-before于它的finalize()方法的开始。

Java内存模型（JMM）是一种规范，用以控制不同线程间的变量访问规则，确保多线程程序执行的正确性和效率。JMM解决了可见性、原子性、有序性等问题，通过定义内存操作的规则，它保障了并发环境中共享变量的一致性和线程安全性。以下是JMM的主要知识点概述：

## 3. 内存操作

JMM定义了如何通过锁和`volatile`关键字来实现变量的同步访问：

- **锁（Synchronized）**：提供了一种互斥机制，确保同一时刻只有一个线程可以执行某段代码。
- **`volatile`关键字**：保证了变量的可见性和部分有序性，但不保证原子性。

### 4. 内存模型的组成

JMM通过以下几部分组成来提供线程之间的通信机制：

- **共享变量**：存储在主内存中，由所有线程共享。
- **本地内存**：每个线程可以有自己的本地内存，其中包含了主内存中共享变量的拷贝。
- **内存操作**：包括读取（load）、写入（store）、锁定（lock）和解锁（unlock）等操作。

### 5. `volatile`的作用

- 确保变量对所有线程的可见性。
- 禁止指令重排序优化。
  [volatile](/java/basic/foundation/thread/volatile.md)

### 6. 锁的优化和升级

JMM允许JVM对锁进行优化，包括轻量级锁、偏向锁和自旋锁等，以提高并发性能。

### 7. 最终规则

- 对于被声明为`final`的字段，构造函数内对这些字段的所有更新对于使用该对象的其他线程都是可见的。
